// src/main.rs

// Import necessary modules from the clap crate for command-line argument parsing.
// `Parser` is a trait that enables deriving a command-line argument parser from a struct.
use clap::Parser;
// Import logging macros from the `log` crate.
// These allow for logging messages at different severity levels (info, error, debug, etc.).
use log::{info, error, warn, debug}; // Added warn and debug for completeness

/// A simple CLI application for {{cookiecutter.project_slug}}, generated by the Rust template.
/// This program demonstrates command-line argument parsing with `clap` and
/// structured logging with `env_logger` and `log`.
///
/// The `#[command(...)]` attributes are read by `clap` from `Cargo.toml`
/// to populate version, author, and about information for the --help message.
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)] // Fetches from Cargo.toml
struct Args {
    /// Name of the person to greet.
    /// This argument is optional and defaults to "World" if not provided.
    /// It can be specified using -n <NAME> or --name <NAME>.
    #[arg(short, long, default_value = "World")]
    name: String,

    /// Number of times to greet the person.
    /// This argument is optional and defaults to 1.
    /// It can be specified using -c <COUNT> or --count <COUNT>.
    #[arg(short, long, default_value_t = 1)]
    count: u8,

    /// Enable verbose logging (debug messages).
    /// If this flag is present, the log level will be set to debug.
    /// Otherwise, it defaults to info (as set by default_filter_or("info")).
    #[arg(short, long)]
    verbose: bool,
}

fn main() {
    // Parse command-line arguments using the Args struct defined with clap.
    // `Args::parse()` will automatically handle argument parsing, validation,
    // and generation of help/version messages based on the struct definition
    // and `#[command(...)]` attributes.
    let args = Args::parse();

    // Initialize `env_logger`.
    // Logging behavior is controlled by the RUST_LOG environment variable.
    // Examples:
    //   - RUST_LOG=info ./my_awesome_project  (Show info, warn, error)
    //   - RUST_LOG=debug ./my_awesome_project (Show debug, info, warn, error)
    //   - RUST_LOG=my_awesome_project=debug   (Show debug for this crate only)
    // If RUST_LOG is not set, it defaults to "info" level logging due to `default_filter_or("info")`.
    // If `args.verbose` is true, we override the filter to "debug".
    let log_level = if args.verbose { "debug" } else { "info" };
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or(log_level)).init();

    // Example of using different log levels:
    debug!("Parsed arguments: {:?}", args); // Only shown if RUST_LOG=debug or --verbose

    // Validate the count argument.
    if args.count == 0 {
        // Use `error!` for critical issues that prevent normal operation.
        error!("Count cannot be zero! Please provide a positive number for count.");
        // Consider exiting with a non-zero status code for scriptability.
        // std::process::exit(1);
        return; // Exit main if count is invalid.
    }

    // Log the greeting multiple times based on the count argument.
    // Use `info!` for standard output messages that indicate normal program flow.
    for i in 0..args.count {
        info!("Hello, {}! (Greeting {}/{})", args.name, i + 1, args.count);
    }

    // Provide a helpful tip if the default name is used.
    if args.name == "World" {
        info!("Try calling with '--name YourName' or '-n YourName' to greet someone specific!");
    }

    info!("Application finished.");
}
